import random
import textwrap
from typing import List
from .room import Room


class Dungeon:
    """Manages the Dungeon

    The Dungeon class manages the dungeon throughout the game. It manages the generation
    of the dungeon and the placement of content in the room. It does not manage any of
    the game play.
    """

    def __init__(
        self, max_rooms: int = 10, map_height: int = 50, map_width: int = 50
    ) -> None:
        """Creates a new Dungeon instance

        The map height and map width are used to bound the placement of rooms. Rooms can't
        be placed on the edge of the map.  By default the map is pretty sparse and the
        player can't see a lot of the rooms around them. To reduce the sparseness
        decrease the height and width.

        Args:
            max_rooms (int, optional): The number of rooms in the maze. Defaults to 10.
            map_height (int, optional): The maximum height of the "map". Defaults to 50.
            map_width (int, optional): The maximum width of the "map" . Defaults to 50.
        """
        self._max_rooms = max_rooms
        self._map_height = map_height
        self._map_width = map_width
        self.rooms = []

    def generate_dungeon(self) -> None:
        """Randomly Generates A New Maze.

        The dungeon is generated by randomly placing rooms within the map and connecting
        the new room to the previously generated room. The process also assigns the maze
        entrance to the first room and the exit to the final rooms generated. The room
        content is also generated when the room is created.

        After all the rooms have been created rooms, excluding the entrance and exit,
        are randomly assigned to hide the game objectives.

        """
        # Rest the maze just in case one was created before.
        self.rooms = []
        num_rooms = 0

        for r in range(self._max_rooms):
            new_room = Room(
                random.randint(1, self._map_width), random.randint(1, self._map_height)
            )

            if num_rooms == 0:
                # Assign the first room created as the entrance
                new_room.generate_room_content("entrance", True, 1.0)

            else:
                # Make connection to previous room
                previous_room = self.rooms[num_rooms - 1]
                self._connect_rooms(new_room, previous_room)

                # Do room content creation.
                # If it is the last room assign an exit and nothing else.
                if num_rooms == (self._max_rooms - 1):
                    new_room.generate_room_content("exit", True, 1.0)
                else:
                    new_room.generate_pit()
                    new_room.generate_healing_potion()
                    new_room.generate_room_content("vision potion", True)

            self.rooms.append(new_room)
            num_rooms += 1
        # Do Pillar Placement
        # TODO: Make this more modular. Objectives should be a argument somewhere.
        self._place_game_objectives(
            ["Abstraction", "Encapsulation", "Inheritance", "Polymorphism"]
        )
        self.maze_status()

    def _connect_rooms(self, new_room: Room, previous_room: Room):
        """Connects the newly created to the previous room.

        The room connections are made based on the concepts of tunnels between the rooms.
        The "tunnel path" is randomly decided and the doors of the two rooms are
        connected based on the "path" taken between the two rooms.

        If the new room is NE of the old room we could draw the tunnel in two ways. The
        tunnel could be dug east first and then north, entering from the south of the new room.
        The other option would be to dig north and then east, entering the east side of
        new room.

        Args:
            new_room (Room): The newly created room object. It will be connected to the
              previous room based on it's relative location and the "tunnel path"
            previous_room (Room): An existing room. It is connected to the new room
              based on the relative location and the "tunnel path" between the rooms.
        """

        # decide if the "tunnel" will go vertical or horizontal first.
        path = self._decide_connection_path()

        # Location 1: New room is SE of previous room.
        if previous_room.x < new_room.x and previous_room.y > new_room.y:
            self._assign_doors(
                path, previous_room, new_room, "East", "North", "South", "West"
            )

        # Location 2: New room NE of pervious room
        elif previous_room.x < new_room.x and previous_room.y < new_room.y:
            self._assign_doors(
                path, previous_room, new_room, "East", "South", "North", "West"
            )

        # Location 3: New Room NW of previous room
        elif previous_room.x > new_room.x and previous_room.y < new_room.y:
            self._assign_doors(
                path, previous_room, new_room, "West", "South", "North", "East"
            )

        # Location 4: New Room SW of previous room
        elif previous_room.x > new_room.x and previous_room.y > new_room.y:
            self._assign_doors(
                path, previous_room, new_room, "West", "North", "South", "East"
            )

        # Location 5: New Room N of previous room
        elif previous_room.x == new_room.x and previous_room.y < new_room.y:
            previous_room.doors["North"] = new_room
            new_room.doors["South"] = previous_room

        # Location 6: New Room S of Previous room.
        elif previous_room.x == new_room.x and previous_room.y > new_room.y:
            previous_room.doors["South"] = new_room
            new_room.doors["North"] = previous_room

        # Location 7 : New Room E of previous room
        elif previous_room.x < new_room.x and previous_room.y == new_room.y:
            previous_room.doors["East"] = new_room
            new_room.doors["West"] = previous_room

        # Location 7 : New Room W of previous room
        elif previous_room.x > new_room.x and previous_room.y == new_room.y:
            previous_room.doors["West"] = new_room
            new_room.doors["East"] = previous_room

    def _decide_connection_path(self):
        """Internal method to decide if the path between to rooms will
        go horizontal or vertical first.
        """
        if random.randint(0, 1) == 1:
            return "H"
        else:
            return "V"

    # TODO: Should this be internal or external? Should this live here or in dungeon_adventure?
    # This should be modular enough to pick it up and move it with minimal changes.
    def _place_game_objectives(self, objectives: List[str]) -> None:
        """Internal method to place the game objective in random rooms.

        Game objectives cannot be placed in rooms with an entrance
        (first room placed) or the room with the exit (last room placed).

        Args:
            objectives (List[str]): A list containing the name of the game objectives.

        Raises:
            ValueError: Indicates that there are not enough rooms in the dungeon
              to place all the objectives
        """
        num_objectives = len(objectives)

        # We do -2 because we can't place things in the entrance or exit rooms.
        if num_objectives > len(self.rooms) - 2:
            raise ValueError(
                "You can't place all of your objectives. There aren't enough eligible rooms"
            )

        object_rooms = random.sample(self.rooms[1:-1], k=num_objectives)
        for index, obj in enumerate(objectives):
            object_rooms[index].generate_room_content("game_objective", obj, 1.0)

    def _assign_doors(
        self,
        path: str,
        previous_room: Room,
        new_room: Room,
        previous_horizontal_door: str,
        new_horizontal_door: str,
        previous_vertical_door: str,
        new_vertical_door: str,
    ):
        """Internal method to connect rooms via "tunnels".

        There are some edge cases where a door is already connected to the
        previous room. When connecting rooms by the doors we first check to make
        sure that a connection does not exist at that door. If a connection exists,
        we make the connection using the alternate tunnel route (horizontal or vertical).

        Args:
            path (str): A string indicating if the default "tunnel path" is
                horizontal ("H") or vertical "V". This is randomly chosen
                using _decide_connection_path
            previous_room (Room): The room last created, which will be connected
                to the current room.
            new_room (Room): The current room being added to the dungeon. It will
                be connected to the previously created room.
            previous_horizontal_door (str): The door used to exit the previous
              room if the "tunnel" goes horizontal first.
            new_horizontal_door (str): The door used to enter the new room if
              the "tunnel" goes horizontal first.
            previous_vertical_door (str):  The door used to exit the previous
              room if the "tunnel" goes vertical first.
            new_vertical_door (str): The door used to enter the new room if
              the "tunnel" goes vertical first.
        """
        # TODO: Add A check that the door strings are valid. Should be North, East, South, West.
        if path == "H":
            # Check to make sure the door isn't in use already. If in use go other path.
            if previous_room.doors[previous_horizontal_door] is False:
                previous_room.doors[previous_horizontal_door] = new_room
                new_room.doors[new_horizontal_door] = previous_room
            else:
                previous_room.doors[previous_vertical_door] = new_room
                new_room.doors[new_vertical_door] = previous_room
        else:
            if previous_room.doors[previous_vertical_door] is False:
                previous_room.doors[previous_vertical_door] = new_room
                new_room.doors[new_vertical_door] = previous_room
            else:
                previous_room.doors[previous_horizontal_door] = new_room
                new_room.doors[new_horizontal_door] = previous_room

    def maze_status(self):
        """Checks on the status of the maze.

        When checking on the status of the maze it checks the rooms for the different
        kinds of objects in the maze and counts the number of each object.
        """
        self.object_counts = {}

        # Find all the items in the maze
        for r in self.rooms:
            for key in r.content.keys():
                if key in self.object_counts.keys():
                    self.object_counts[key] += 1
                else:
                    self.object_counts[key] = 1

    def __str__(self):
        """String representation of the maze.

        It reports on the number of rooms and the types of objects in the maze. The quantity
        of each object is reported too.
        """
        content_list = [f"{k}: {v}" for k, v in self.object_counts.items()]
        content_str = "\n\t".join(content_list)
        msg = textwrap.dedent(
            f"""
        The Maze is deep and twisting. There are {len(self.rooms)} rooms to explore and survive.
        Hidden in the maze, you can find:

        {content_str}.
            """
        )

        return msg

    def print_dungeon_map(self):
        """Prints a map of the dungeon to the terminal

        The map of the dungeon is implemented as a list of lists. Each list
        is a representation of row of the dungeon. Within a given row, each item
        in the list represents a column in the dungeon. If a space in the dungeon
        is empty(there isn't a room there), it is represented by an empty string.
        if a room is present at the given coordinate the string representation of
        that room is provided.
        """
        dungeon_map = self._map_whole_dungeon()
        for i in dungeon_map:
            print(i)

    def _map_whole_dungeon(self) -> List[List[str]]:
        """Internal method for generating the map of the dungeon.

        The map of the dungeon is implemented as a list of lists. Each list
        is a representation of row of the dungeon. Within a given row, each item
        in the list represents a column in the dungeon. If a space in the dungeon
        is empty(there isn't a room there), it is represented by an empty string.
        if a room is present at the given coordinate the string representation of
        that room is provided.

        Returns:
            list: See detailed explanation.
        """
        map_storage = []
        for a in range(1, self._map_height + 1):
            map_storage.append(["   "] * (self._map_width))
            for room in self.rooms:
                if room.y == a:
                    map_storage[a - 1][room.x - 1] = str(room)
        # The map is ordered from bottom to top. If we print the list in this
        # way the top row would be the bottom of the dungeon, hence the reverse.
        map_storage.reverse()
        return map_storage
